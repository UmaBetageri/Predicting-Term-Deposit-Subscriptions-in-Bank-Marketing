# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pT8ZztrgzsbhZecSjcpoFuLJZN9MGb8F
"""

import streamlit as st
import joblib
import pandas as pd
from sklearn.preprocessing import MinMaxScaler
import zipfile
import os

# Unzip the compressed model
with zipfile.ZipFile('random_forest_model.pkl.zip', 'r') as zip_ref:
    zip_ref.extractall()  # Extracts all files from the zip to the current directory

# Load model and scaler
model = joblib.load('random_forest_model.pkl')
scaler = joblib.load('scaler.pkl')

# Define the encoding dictionaries
encoding = {
    'job': {'admin.': 0, 'blue-collar': 1, 'entrepreneur': 2, 'housemaid': 3, 'management': 4, 'retired': 5, 'self-employed': 6, 'services': 7, 'student': 8, 'technician': 9, 'unemployed': 10, 'unknown': 11},
    'marital': {'divorced': 0, 'married': 1, 'single': 2, 'unknown': 3},
    'education': {'basic.4y': 0, 'basic.6y': 1, 'basic.9y': 2, 'high.school': 3, 'illiterate': 4, 'professional.course': 5, 'university.degree': 6, 'unknown': 7},
    'default': {'no': 0, 'unknown': 1, 'yes': 2},
    'housing': {'no': 0, 'unknown': 1, 'yes': 2},
    'loan': {'no': 0, 'unknown': 1, 'yes': 2},
    'contact': {'cellular': 0, 'telephone': 1},
    'month': {'apr': 0, 'aug': 1, 'dec': 2, 'jul': 3, 'jun': 4, 'mar': 5, 'may': 6, 'nov': 7, 'oct': 8, 'sep': 9},
    'day_of_week': {'fri': 0, 'mon': 1, 'thu': 2, 'tue': 3, 'wed': 4},
    'poutcome': {'failure': 0, 'nonexistent': 1, 'success': 2}
}

# Define the user-friendly dropdown options
dropdown_options = {
    'job': ['Select', 'admin.', 'blue-collar', 'entrepreneur', 'housemaid', 'management', 'retired', 'self-employed', 'services', 'student', 'technician', 'unemployed', 'unknown'],
    'marital': ['Select', 'single', 'married', 'divorced', 'unknown'],
    'education': ['Select', 'basic.4y', 'basic.6y', 'basic.9y', 'high.school', 'illiterate', 'professional.course', 'university.degree', 'unknown'],
    'default': ['Select', 'yes', 'no', 'unknown'],
    'housing': ['Select', 'yes', 'no', 'unknown'],
    'loan': ['Select', 'yes', 'no', 'unknown'],
    'contact': ['Select', 'cellular', 'telephone'],
    'month': ['Select', 'jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec'],
    'day_of_week': ['Select', 'mon', 'tue', 'wed', 'thu', 'fri'],
    'poutcome': ['Select', 'failure', 'success', 'nonexistent']
}

def preprocess_input(data):
    # Assuming data is a dictionary with feature names as keys
    df = pd.DataFrame([data])

    # Encode categorical features
    for feature, mapping in encoding.items():
        if feature in df.columns:
            df[feature] = df[feature].map(mapping)

    # Apply MinMaxScaler to numerical features
    numerical_features = ['age', 'duration', 'campaign', 'pdays', 'previous', 'cons_price_idx', 'cons_conf_idx', 'nr_employed']
    df[numerical_features] = scaler.transform(df[numerical_features])

    return df

def main():
    st.title("Prediction of Term Deposit Subscriptions in Bank Marketing")

    # Input fields
    age = st.number_input('Age', min_value=16, step=1, format="%d", value=None)
    job = st.selectbox('Job', dropdown_options['job'])
    marital = st.selectbox('Marital Status', dropdown_options['marital'])
    education = st.selectbox('Education', dropdown_options['education'])
    default = st.selectbox('Credit in Default', dropdown_options['default'])
    housing = st.selectbox('Housing Loan', dropdown_options['housing'])
    loan = st.selectbox('Personal Loan', dropdown_options['loan'])
    contact = st.selectbox('Contact Communication Type', dropdown_options['contact'])
    month = st.selectbox('Last Contact Month of Year', dropdown_options['month'])
    day_of_week = st.selectbox('Last Contact Day of the Week', dropdown_options['day_of_week'])
    duration = st.number_input('Duration', min_value=0, step=1, format="%d", value=None)
    campaign = st.number_input('Campaign', min_value=0, step=1, format="%d", value=None)
    pdays = st.number_input('Pdays', min_value=0, step=1, format="%d", value=None)
    previous = st.number_input('Previous', min_value=0, step=1, format="%d", value=None)
    poutcome = st.selectbox('Poutcome', dropdown_options['poutcome'])
    cons_price_idx = st.number_input('Consumer Price Index', min_value=0.0, step=0.01, format="%.2f", value=None)
    cons_conf_idx = st.number_input('Consumer Confidence Index', step=0.01, format="%.2f", value=None)
    nr_employed = st.number_input('Number of Employees', min_value=0.0, step=0.01, format="%.2f", value=None)

    # Predict button
    if st.button('Predict'):
        # Create data dictionary
        data = {
            'age': age,
            'job': job,
            'marital': marital,
            'education': education,
            'default': default,
            'housing': housing,
            'loan': loan,
            'contact': contact,
            'month': month,
            'day_of_week': day_of_week,
            'duration': duration,
            'campaign': campaign,
            'pdays': pdays,
            'previous': previous,
            'poutcome': poutcome,
            'cons_price_idx': cons_price_idx,
            'cons_conf_idx': cons_conf_idx,
            'nr_employed': nr_employed
        }

        # Validate inputs
        if any(value is None or value == 'Select' for value in data.values()):
            st.error("Please fill all the fields with valid inputs.")
        else:
            # Preprocess and predict
            processed_data = preprocess_input(data)
            processed_data = processed_data.apply(pd.to_numeric, errors='coerce')

            # Predict the outcome
            prediction = model.predict(processed_data)
            prediction_prob = model.predict_proba(processed_data)

            # Display results
            st.write('Prediction:', 'The client is likely to subscribe to a term deposit.' if prediction[0] == 1 else 'The client is unlikely to subscribe to a term deposit.')
            st.write(f"Probability of subscription: {prediction_prob[0][1]:.4f}")

if __name__ == "__main__":
    main()